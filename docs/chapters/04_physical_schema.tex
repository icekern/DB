\chapter{Physical Implementation}
\label{ch:physical_schema}

In this chapter we turn the logical schema into real Oracle SQL code. We write \texttt{CREATE TABLE} statements with constraints, triggers for the business rules, and stored procedures for the main operations.

\section{Tables Definition}

Tables are created in the right order: independent entities first, then the bridge tables that link them. All constraints (CHECK, NOT NULL, primary and foreign keys) are written inline.

\begin{sqlbox}[title={Core Independent Entities}]
CREATE TABLE Sponsor ( -- just the name as PK
    name VARCHAR2(100) PRIMARY KEY
);

CREATE TABLE Conference ( -- main conference table
    acronym      VARCHAR2(50)  PRIMARY KEY,
    name         VARCHAR2(100) NOT NULL,
    location     VARCHAR2(100),
    homepage_url VARCHAR2(150)
);

CREATE TABLE Organizer ( -- committee member / reviewer
    code        VARCHAR2(20)  PRIMARY KEY,
    name        VARCHAR2(100) NOT NULL,
    affiliation VARCHAR2(100),
    address     VARCHAR2(200),
    phone       VARCHAR2(20),
    email       VARCHAR2(100)
);

CREATE TABLE ResearchArea ( -- research areas for matching
    area_acronym VARCHAR2(20)  PRIMARY KEY,
    area_name    VARCHAR2(100) NOT NULL,
    description  VARCHAR2(500)
);

CREATE TABLE Author ( -- paper authors
    code        VARCHAR2(20)  PRIMARY KEY,
    name        VARCHAR2(100) NOT NULL,
    affiliation VARCHAR2(100),
    address     VARCHAR2(200),
    phone       VARCHAR2(20),
    email       VARCHAR2(100)
);

CREATE TABLE Partner ( -- industrial partners, BR12
    code    VARCHAR2(20)  PRIMARY KEY,
    name    VARCHAR2(100) NOT NULL,
    address VARCHAR2(200)
);
\end{sqlbox}

\begin{sqlbox}[title={Article Entity}]
CREATE TABLE Article (
    article_id           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    conference_acronym   VARCHAR2(50) NOT NULL,
    seq_number           INT          NOT NULL,
    title                VARCHAR2(200) NOT NULL,
    category             VARCHAR2(50)  NOT NULL
        CHECK (category IN ('Industrial Paper', 'Research Paper',
                            'Tutorial', 'Poster', 'Short Paper')), -- BR4
    status               VARCHAR2(20) DEFAULT 'pending'
        CHECK (status IN ('pending', 'accepted', 'rejected')), -- BR10
    avg_global_score     FLOAT DEFAULT 0.0, -- updated by trigger BR13
    contact_author_code  VARCHAR2(20) NOT NULL, -- must be in Authorship (BR8)
    FOREIGN KEY (conference_acronym) REFERENCES Conference(acronym),
    FOREIGN KEY (contact_author_code) REFERENCES Author(code),
    CONSTRAINT unique_conference_seq UNIQUE (conference_acronym, seq_number)
);
\end{sqlbox}

\begin{sqlbox}[title={Bridge Relations (N:M Mappings)}]
CREATE TABLE Sponsorship ( -- sponsor <-> conference link
    sponsor_name       VARCHAR2(100),
    conference_acronym VARCHAR2(50),
    funding_date       DATE   NOT NULL,
    funded_amount      NUMBER NOT NULL CHECK (funded_amount > 0), -- BR7
    PRIMARY KEY (sponsor_name, conference_acronym),
    FOREIGN KEY (sponsor_name)       REFERENCES Sponsor(name),
    FOREIGN KEY (conference_acronym) REFERENCES Conference(acronym)
);

CREATE TABLE Membership ( -- committee membership, BR9 checks min 2
    organizer_code     VARCHAR2(20),
    conference_acronym VARCHAR2(50),
    PRIMARY KEY (organizer_code, conference_acronym),
    FOREIGN KEY (organizer_code)     REFERENCES Organizer(code),
    FOREIGN KEY (conference_acronym) REFERENCES Conference(acronym)
);

CREATE TABLE AreaIndication ( -- 3-way bridge: org+conf+area
    organizer_code     VARCHAR2(20),
    conference_acronym VARCHAR2(50),
    area_acronym       VARCHAR2(20),
    PRIMARY KEY (organizer_code, conference_acronym, area_acronym),
    FOREIGN KEY (organizer_code)     REFERENCES Organizer(code),
    FOREIGN KEY (conference_acronym) REFERENCES Conference(acronym),
    FOREIGN KEY (area_acronym)       REFERENCES ResearchArea(area_acronym)
);

CREATE TABLE Authorship ( -- who wrote which article
    article_id  NUMBER,
    author_code VARCHAR2(20),
    PRIMARY KEY (article_id, author_code),
    FOREIGN KEY (article_id)  REFERENCES Article(article_id) ON DELETE CASCADE,
    FOREIGN KEY (author_code) REFERENCES Author(code)
);

CREATE TABLE ArticleAreaIndication ( -- article <-> area link
    article_id   NUMBER,
    area_acronym VARCHAR2(20),
    PRIMARY KEY (article_id, area_acronym),
    FOREIGN KEY (article_id)   REFERENCES Article(article_id) ON DELETE CASCADE,
    FOREIGN KEY (area_acronym) REFERENCES ResearchArea(area_acronym)
);

CREATE TABLE Contribution ( -- partner contribution, only for Industrial
    article_id   NUMBER,
    partner_code VARCHAR2(20),
    PRIMARY KEY (article_id, partner_code),
    FOREIGN KEY (article_id)   REFERENCES Article(article_id) ON DELETE CASCADE,
    FOREIGN KEY (partner_code) REFERENCES Partner(code)
);
\end{sqlbox}

\begin{sqlbox}[title={Review Entity}]
CREATE TABLE Review ( -- the actual review, scores 0-10
    code          VARCHAR2(20) PRIMARY KEY,
    review_date   DATE         NOT NULL,
    content       CLOB,
    originality   INT  CHECK (originality  BETWEEN 0 AND 10), -- BR10 range
    significance  INT  CHECK (significance BETWEEN 0 AND 10),
    quality       INT  CHECK (quality      BETWEEN 0 AND 10),
    global_score  INT  CHECK (global_score BETWEEN 0 AND 10),
    comments      CLOB,
    article_id    NUMBER       NOT NULL, -- FK to Article
    reviewer_code VARCHAR2(20) NOT NULL, -- FK to Organizer (reviewer)
    FOREIGN KEY (article_id)    REFERENCES Article(article_id) ON DELETE CASCADE,
    FOREIGN KEY (reviewer_code) REFERENCES Organizer(code)
);
\end{sqlbox}

\clearpage

\section{Triggers and Business Rules}

We use Oracle PL/SQL triggers to enforce the business rules that cannot be done with simple CHECK constraints or foreign keys. Each trigger checks one specific rule before or after an operation on a table. The trigger names follow the pattern \texttt{trg\_brN\_description} so it is easy to see which rule each trigger enforces.

\begin{infobox}
To write the triggers, I studied the Oracle PL/SQL documentation (especially the sections on row-level triggers and compound triggers) to understand the mutating table problem and how compound triggers solve it.
\end{infobox}

\begin{sqlbox}[title={Trigger: BR1 -- Maximum Reviewer Cardinality}]
CREATE OR REPLACE TRIGGER trg_br1_max_reviewers
BEFORE INSERT ON Review  -- before we insert on review for each row
FOR EACH ROW
DECLARE
    v_count INT; -- aux variable we need to store the reviewer count
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM Review
    WHERE article_id = :NEW.article_id; --simple review count select

    IF v_count >= 4 THEN --throw error abort this operation
        RAISE_APPLICATION_ERROR(-20001,
          'BR1: An article cannot have more than 4 reviewers.');
    END IF;
END;
/
\end{sqlbox}

% Before inserting a new Review row, this trigger counts how many reviews
% already exist for the same article. If 4 or more are found, the insert
% is blocked. This enforces the (2,4) cardinality on the About relationship.

\begin{sqlbox}[title={Trigger: BR2 -- Reviewer Conference Membership}]
CREATE OR REPLACE TRIGGER trg_br2_reviewer_conf_match
BEFORE INSERT OR UPDATE ON Review  -- fires on insert or update
FOR EACH ROW
DECLARE
    v_article_conf        VARCHAR2(50); -- conference of the article
    v_reviewer_conf_count INT; -- check if reviewer is member
BEGIN
    SELECT conference_acronym INTO v_article_conf
    FROM Article WHERE article_id = :NEW.article_id; -- get the conference

    SELECT COUNT(*) INTO v_reviewer_conf_count
    FROM Membership
    WHERE organizer_code     = :NEW.reviewer_code
      AND conference_acronym = v_article_conf; -- is this reviewer in the committee?

    IF v_reviewer_conf_count = 0 THEN -- not a member, block it
        RAISE_APPLICATION_ERROR(-20002,
          'BR2: Reviewer must be in the program committee.');
    END IF;
END;
/
\end{sqlbox}

% Looks up the conference of the article being reviewed, then checks
% if the reviewer is actually a member of that conference's program
% committee. If not, the review is rejected.

\begin{sqlbox}[title={Trigger: BR3 -- Research Area Compatibility}]
CREATE OR REPLACE TRIGGER trg_br3_reviewer_area_match
BEFORE INSERT OR UPDATE ON Review  -- check area compatibility
FOR EACH ROW
DECLARE
    v_overlap INT; -- how many areas in common
BEGIN
    SELECT COUNT(*) INTO v_overlap
    FROM AreaIndication ai
    JOIN ArticleAreaIndication aai
      ON aai.area_acronym = ai.area_acronym
    JOIN Article art
      ON aai.article_id = art.article_id
    WHERE ai.organizer_code = :NEW.reviewer_code
      AND aai.article_id    = :NEW.article_id
      AND ai.conference_acronym
                            = art.conference_acronym; -- join to find overlap
    IF v_overlap = 0 THEN -- no overlap means no match
        RAISE_APPLICATION_ERROR(-20003,
          'BR3: Reviewer areas must overlap with article areas.');
    END IF;
END;
/
\end{sqlbox}

% Joins AreaIndication (what the reviewer declared) with
% ArticleAreaIndication (what the article covers) for the same
% conference. If there is zero overlap, the assignment is rejected.

\begin{infobox}
BR4 (score range $[0,10]$) and BR10 (positive sponsorship amount) are enforced declaratively via inline \texttt{CHECK} constraints on the respective table columns. BR7 (single conference submission) is enforced by the foreign key design of Article.
\end{infobox}

\begin{sqlbox}[title={Trigger: BR5 \& BR6 -- Status Determination}]
CREATE OR REPLACE TRIGGER trg_br5_br6_article_status
BEFORE UPDATE OF status ON Article  -- only fires when status changes
FOR EACH ROW
DECLARE
    v_total_reviews     INT; -- total reviews assigned
    v_completed_reviews INT; -- reviews that have a global_score
BEGIN
    IF :OLD.status = 'pending'
       AND :NEW.status != 'pending'
    THEN -- only when leaving pending
        SELECT COUNT(*) INTO v_total_reviews
        FROM Review
        WHERE article_id = :NEW.article_id; -- count all reviews

        SELECT COUNT(*) INTO v_completed_reviews
        FROM Review
        WHERE article_id = :NEW.article_id
          AND global_score IS NOT NULL; -- count only completed ones

        IF v_total_reviews < 2 THEN -- need at least 2 reviews
            RAISE_APPLICATION_ERROR(-20006,
              'BR6: Min 2 reviews required.');
        END IF;
        IF v_total_reviews != v_completed_reviews THEN -- all must be done
            RAISE_APPLICATION_ERROR(-20005,
              'BR5: All reviews must be done.');
        END IF;
    END IF;
END;
/
\end{sqlbox}

% Fires only when the status column changes away from 'pending'.
% First checks that the article has at least 2 reviews (BR6), then
% checks that every assigned review has a global\_score filled in (BR5).
% If either condition fails, the status update is rolled back.

\begin{sqlbox}[title={Trigger: BR8 -- Contact Author Subset}]
CREATE OR REPLACE TRIGGER trg_br8_contact_is_author
AFTER INSERT OR UPDATE ON Article  -- after because authorship comes later
FOR EACH ROW
DECLARE
    v_is_author INT; -- check if contact is in authorship table
BEGIN
    SELECT COUNT(*) INTO v_is_author
    FROM Authorship
    WHERE article_id  = :NEW.article_id
      AND author_code = :NEW.contact_author_code; -- is this person an author?
    IF v_is_author = 0 AND NOT INSERTING THEN -- skip on insert, authorship comes after
        RAISE_APPLICATION_ERROR(-20008,
          'BR8: Contact author must be one of the authors.');
    END IF;
END;
/
\end{sqlbox}

% After an article is inserted or updated, verifies that the
% contact\_author\_code actually appears in the Authorship table for
% that article. On INSERT we skip the check because the Authorship
% row is created right after by the procedure; on UPDATE we enforce it.

\begin{sqlbox}[title={Trigger: BR11 -- Acceptance Score Threshold}]
CREATE OR REPLACE TRIGGER trg_br11_acceptance_threshold
BEFORE UPDATE OF status ON Article  -- check before accepting
FOR EACH ROW
BEGIN
    IF :NEW.status = 'accepted'
       AND :NEW.avg_global_score < 5
    THEN -- score too low
        RAISE_APPLICATION_ERROR(-20011,
          'BR11: avg score must be >= 5 to accept.');
    END IF;
END;
/
\end{sqlbox}

% Before setting an article to 'accepted', checks that the cached
% avg\_global\_score is at least 5. If not, the update is rejected.

\begin{sqlbox}[title={Trigger: BR12 -- Industrial Paper Only}]
CREATE OR REPLACE TRIGGER trg_br12_industrial_paper_only
BEFORE INSERT OR UPDATE ON Contribution  -- check before linking partner
FOR EACH ROW
DECLARE
    v_category VARCHAR2(50); -- article category
BEGIN
    SELECT category INTO v_category
    FROM Article
    WHERE article_id = :NEW.article_id; -- what kind of article is this?
    IF v_category != 'Industrial Paper' THEN -- not industrial? block
        RAISE_APPLICATION_ERROR(-20012,
          'BR12: Partners can only contribute to Industrial Papers.');
    END IF;
END;
/
\end{sqlbox}

% Before inserting a Contribution row, reads the category of the
% linked article. If the article is not an Industrial Paper, the
% contribution is blocked.

\subsection{Compound Triggers (BR9 and BR13)}

The two triggers below use the Oracle compound trigger syntax. This is needed when a trigger on a table also needs to query or update the same table. In a normal row-level trigger, Oracle raises the ``mutating table'' error (ORA-04091) if you try to read the table being modified. The compound trigger solves this by splitting the logic into two phases:

\begin{enumerate}
  \item \textbf{AFTER EACH ROW}: collects the keys of the affected rows into a temporary array.
  \item \textbf{AFTER STATEMENT}: after all rows have been processed, reads the table (which is now stable) and applies the validation logic.
\end{enumerate}


\begin{sqlbox}[title={Trigger: BR9 -- Minimum Committee Size (Compound)}]
CREATE OR REPLACE TRIGGER trg_br9_min_committee
FOR DELETE ON Membership  -- fires when we remove someone from committee
COMPOUND TRIGGER
    TYPE t_confs IS TABLE OF VARCHAR2(50)
      INDEX BY PLS_INTEGER;
    g_confs t_confs; -- collect affected conferences
    g_idx   PLS_INTEGER := 0;

    AFTER EACH ROW IS
    BEGIN
        g_idx := g_idx + 1;
        g_confs(g_idx) := :OLD.conference_acronym; -- save which conference
    END AFTER EACH ROW;

    AFTER STATEMENT IS
        v_count INT; -- remaining members count
    BEGIN
        FOR i IN 1..g_idx LOOP
            SELECT COUNT(*) INTO v_count
            FROM Membership
            WHERE conference_acronym = g_confs(i); -- how many left?
            IF v_count < 2 THEN -- too few, block
                RAISE_APPLICATION_ERROR(-20009,
                  'BR9: Min 2 committee members required.');
            END IF;
        END LOOP;
    END AFTER STATEMENT;
END trg_br9_min_committee;
/
\end{sqlbox}

% When rows are deleted from Membership, the AFTER EACH ROW phase
% saves the conference acronyms. Then the AFTER STATEMENT phase
% checks that each conference still has at least 2 committee members.

\begin{sqlbox}[title={Trigger: BR13 -- Avg Score Maintenance (Compound)}]
CREATE OR REPLACE TRIGGER trg_br13_update_avg_score
FOR INSERT OR UPDATE OF global_score
    OR DELETE ON Review  -- fires on any score change
COMPOUND TRIGGER
    TYPE t_ids IS TABLE OF NUMBER
      INDEX BY PLS_INTEGER;
    g_ids t_ids; -- collect affected article ids
    g_idx PLS_INTEGER := 0;

    AFTER EACH ROW IS
    BEGIN
        g_idx := g_idx + 1;
        IF DELETING THEN
            g_ids(g_idx) := :OLD.article_id; -- deleted row, use OLD
        ELSE
            g_ids(g_idx) := :NEW.article_id; -- inserted/updated, use NEW
        END IF;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
        v_avg FLOAT; -- new average
    BEGIN
        FOR i IN 1..g_idx LOOP
            SELECT NVL(AVG(global_score), 0)
            INTO v_avg
            FROM Review
            WHERE article_id = g_ids(i); -- recalculate avg

            UPDATE Article
            SET avg_global_score = v_avg
            WHERE article_id = g_ids(i); -- save it back
        END LOOP;
    END AFTER STATEMENT;
END trg_br13_update_avg_score;
/
\end{sqlbox}

% Compound trigger that maintains the redundant avg\_global\_score in
% Article. On every INSERT, UPDATE, or DELETE on Review, it collects
% the affected article\_ids, then recalculates the average from all
% remaining reviews and writes it back to the Article row.

\clearpage

\section{Procedures}

These PL/SQL stored procedures do the main operations (OP1--OP4). Each procedure handles its own transaction with COMMIT and ROLLBACK.

\begin{sqlbox}[title={Procedure: Submit a New Article (OP1)}]
CREATE OR REPLACE PROCEDURE prc_submit_article (
    p_conf_acronym  IN  VARCHAR2, -- which conference
    p_title         IN  VARCHAR2,
    p_category      IN  VARCHAR2,
    p_contact_code  IN  VARCHAR2, -- contact author code
    p_out_article_id OUT NUMBER   -- returns the new article id
)
AS
    v_seq NUMBER; -- next seq number for this conference
BEGIN
    SELECT NVL(MAX(seq_number), 0) + 1 INTO v_seq
    FROM Article
    WHERE conference_acronym = p_conf_acronym; -- get next seq

    INSERT INTO Article (
        conference_acronym, seq_number,
        title, category, status,
        contact_author_code
    ) VALUES (
        p_conf_acronym, v_seq,
        p_title, p_category, 'pending',
        p_contact_code
    ) RETURNING article_id INTO p_out_article_id; -- grab the generated id

    INSERT INTO Authorship (article_id, author_code)
    VALUES (p_out_article_id, p_contact_code); -- also add as author

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/
\end{sqlbox}

\begin{sqlbox}[title={Procedure: Assign a Reviewer to an Article}]
CREATE OR REPLACE PROCEDURE prc_assign_reviewer (
    p_article_id     IN NUMBER,
    p_reviewer_code  IN VARCHAR2
)
AS
    v_code VARCHAR2(20); -- auto-generated review code
BEGIN
    v_code := 'REV-' || p_article_id
              || '-' || SUBSTR(p_reviewer_code, 1, 4); -- build the code

    INSERT INTO Review (
        code, review_date, article_id, reviewer_code
    ) VALUES (
        v_code, SYSDATE, p_article_id, p_reviewer_code
    ); -- triggers BR1, BR2, BR3 will fire here

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/
\end{sqlbox}

\begin{sqlbox}[title={Procedure: Submit a Review (OP3)}]
CREATE OR REPLACE PROCEDURE prc_add_review (
    p_code         IN VARCHAR2, -- review code (already created by assign)
    p_originality  IN INT,
    p_significance IN INT,
    p_quality      IN INT,
    p_comments     IN CLOB,
    p_content      IN CLOB
)
AS
    v_global_score INT; -- calculated average of the 3 scores
BEGIN
    v_global_score := ROUND(
        (p_originality + p_significance + p_quality) / 3
    ); -- simple avg, rounded

    UPDATE Review
    SET review_date  = SYSDATE,
        content      = p_content,
        originality  = p_originality,
        significance = p_significance,
        quality      = p_quality,
        global_score = v_global_score, -- this triggers BR13 to update avg
        comments     = p_comments
    WHERE code = p_code;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/
\end{sqlbox}

\begin{sqlbox}[title={Procedure: Get Reviewer Assignments (OP2)}]
CREATE OR REPLACE PROCEDURE prc_get_reviewer_assignments (
    p_reviewer_code IN  VARCHAR2,
    p_cursor        OUT SYS_REFCURSOR -- returns the result set
)
AS
BEGIN
    OPEN p_cursor FOR
        SELECT
            art.title,
            art.category,
            ( -- subquery to get all authors as comma-separated list
                SELECT LISTAGG(au.name, ', ')
                  WITHIN GROUP (ORDER BY au.name)
                FROM Authorship auth
                JOIN Author au ON auth.author_code = au.code
                WHERE auth.article_id = art.article_id
            ) AS authors_list
        FROM Review rev
        JOIN Article art ON rev.article_id = art.article_id
        WHERE rev.reviewer_code = p_reviewer_code; -- filter by reviewer
END;
/
\end{sqlbox}

\begin{sqlbox}[title={Procedure: Get Accepted Articles per Conference (OP4)}]
CREATE OR REPLACE PROCEDURE prc_get_accepted_articles (
    p_acronym IN  VARCHAR2,
    p_cursor  OUT SYS_REFCURSOR -- returns accepted articles
)
AS
BEGIN
    OPEN p_cursor FOR
        SELECT
            art.category,
            art.title,
            a.name  AS contact_author_name,
            a.email AS contact_author_email,
            art.avg_global_score
        FROM Article art
        JOIN Author a ON art.contact_author_code = a.code
        WHERE art.conference_acronym = p_acronym
          AND art.status = 'accepted' -- only accepted ones
        ORDER BY art.category, art.title;
END;
/
\end{sqlbox}

\clearpage

\section{Utility Constructors}

These two utility procedures help set up entities that need multiple tables at once. They are used by the population script and the web app.

\begin{sqlbox}[title={Utility: Initialize a Conference with Committee}]
CREATE OR REPLACE PROCEDURE util_init_conference (
    p_acronym    IN VARCHAR2,
    p_name       IN VARCHAR2,
    p_location   IN VARCHAR2,
    p_url        IN VARCHAR2,
    p_org_codes  IN VARCHAR2,  -- comma-separated organizer codes
    p_area_acr   IN VARCHAR2   -- comma-separated area acronyms
)
AS
    v_org   VARCHAR2(20);  -- current organizer being parsed
    v_area  VARCHAR2(20);  -- current area being parsed
    v_pos   INT;           -- comma position
    v_str   VARCHAR2(4000); -- working string for parsing
BEGIN
    -- create the conference first
    INSERT INTO Conference (acronym, name, location, homepage_url)
    VALUES (p_acronym, p_name, p_location, p_url);

    -- parse organizer codes one by one
    v_str := p_org_codes || ',';
    WHILE INSTR(v_str, ',') > 0 LOOP
        v_pos := INSTR(v_str, ',');
        v_org := TRIM(SUBSTR(v_str, 1, v_pos - 1));
        v_str := SUBSTR(v_str, v_pos + 1);

        INSERT INTO Membership (organizer_code, conference_acronym)
        VALUES (v_org, p_acronym); -- add to committee

        -- now assign all areas to this organizer
        DECLARE
            v_astr VARCHAR2(4000) := p_area_acr || ',';
            v_apos INT;
        BEGIN
            WHILE INSTR(v_astr, ',') > 0 LOOP
                v_apos := INSTR(v_astr, ',');
                v_area := TRIM(SUBSTR(v_astr, 1, v_apos - 1));
                v_astr := SUBSTR(v_astr, v_apos + 1);
                BEGIN
                    INSERT INTO AreaIndication
                        (organizer_code, conference_acronym, area_acronym)
                    VALUES (v_org, p_acronym, v_area);
                EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; -- skip dups
                END;
            END LOOP;
        END;
    END LOOP;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/
\end{sqlbox}

\begin{sqlbox}[title={Utility: Register an Article with Authors and Areas}]
CREATE OR REPLACE PROCEDURE util_register_article (
    p_conf_acronym   IN  VARCHAR2,
    p_title          IN  VARCHAR2,
    p_category       IN  VARCHAR2,
    p_contact_code   IN  VARCHAR2,
    p_author_codes   IN  VARCHAR2,  -- comma-separated author codes
    p_area_acronyms  IN  VARCHAR2,  -- comma-separated area acronyms
    p_out_article_id OUT NUMBER     -- returns the new article id
)
AS
    v_seq  NUMBER;        -- next seq number
    v_code VARCHAR2(20);  -- current author code being parsed
    v_area VARCHAR2(20);  -- current area being parsed
    v_pos  INT;           -- comma position
    v_str  VARCHAR2(4000); -- working string
BEGIN
    -- get next seq number for this conference
    SELECT NVL(MAX(seq_number), 0) + 1 INTO v_seq
    FROM Article WHERE conference_acronym = p_conf_acronym;

    -- insert the article
    INSERT INTO Article (
        conference_acronym, seq_number, title, category,
        status, contact_author_code
    ) VALUES (
        p_conf_acronym, v_seq, p_title, p_category,
        'pending', p_contact_code
    ) RETURNING article_id INTO p_out_article_id; -- grab the id

    -- parse and add each author
    v_str := p_author_codes || ',';
    WHILE INSTR(v_str, ',') > 0 LOOP
        v_pos := INSTR(v_str, ',');
        v_code := TRIM(SUBSTR(v_str, 1, v_pos - 1));
        v_str := SUBSTR(v_str, v_pos + 1);
        BEGIN
            INSERT INTO Authorship (article_id, author_code)
            VALUES (p_out_article_id, v_code);
        EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; -- skip dups
        END;
    END LOOP;

    -- parse and add each area
    v_str := p_area_acronyms || ',';
    WHILE INSTR(v_str, ',') > 0 LOOP
        v_pos := INSTR(v_str, ',');
        v_area := TRIM(SUBSTR(v_str, 1, v_pos - 1));
        v_str := SUBSTR(v_str, v_pos + 1);
        BEGIN
            INSERT INTO ArticleAreaIndication (article_id, area_acronym)
            VALUES (p_out_article_id, v_area);
        EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL; -- skip dups
        END;
    END LOOP;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/
\end{sqlbox}

\clearpage

\section{Database Population Data}

This PL/SQL script fills the database with test data that matches the volume table from Chapter~3. It uses round-robin patterns to spread the data evenly.

\begin{infobox}
The script uses Oracle \texttt{IDENTITY} for auto-generated IDs, \texttt{RETURNING INTO} to get the generated keys, and \texttt{BEGIN...EXCEPTION} blocks to skip duplicates.
\end{infobox}

\begin{sqlbox}[title={PL/SQL System Volume Populator Script (Condensed)}]
SET SERVEROUTPUT ON;
DECLARE
    v_conf_acronym VARCHAR2(50);
    v_org_code     VARCHAR2(20);
    v_author_code  VARCHAR2(20);
    v_article_id   NUMBER;
    v_review_code  VARCHAR2(20);
    v_category     VARCHAR2(50);
    v_area_acronym VARCHAR2(20);
BEGIN
    -- 1. Seed research areas (3 areas)
    INSERT INTO ResearchArea (area_acronym, area_name, description)
    VALUES ('DB_SYS', 'Database Systems', 'Storage and querying.');
    INSERT INTO ResearchArea (area_acronym, area_name, description)
    VALUES ('SW_ENG', 'Software Engineering', 'Testing and architecture.');
    INSERT INTO ResearchArea (area_acronym, area_name, description)
    VALUES ('AI', 'Artificial Intelligence', 'ML, reasoning, agents.');

    -- 2. Sponsors (20), Partners (480), Authors (3600)
    FOR i IN 1..20 LOOP
        INSERT INTO Sponsor (name) VALUES ('Sponsor_' || i);
    END LOOP;
    FOR i IN 1..480 LOOP
        INSERT INTO Partner (code, name, address)
        VALUES ('P_' || i, 'Partner Corp ' || i, 'City ' || i);
    END LOOP;
    FOR i IN 1..3600 LOOP
        INSERT INTO Author (
            code, name, affiliation,
            address, phone, email
        ) VALUES (
            'A_' || i, 'Author ' || i,
            'Uni_' || MOD(i, 50),
            'Addr ' || i, '555-' || i,
            'auth' || i || '@test.com'
        );
    END LOOP;

    -- 3. Main Conference Loop (100 Conferences)
    FOR c IN 1..100 LOOP
        v_conf_acronym := 'CONF_' || c;
        INSERT INTO Conference (acronym, name, location, homepage_url)
        VALUES (v_conf_acronym, 'Conference ' || c,
                'City_' || c, 'http://conf' || c || '.org');

        -- 5 sponsors per conference
        FOR s IN 1..5 LOOP
            INSERT INTO Sponsorship (sponsor_name, conference_acronym,
                                     funding_date, funded_amount)
            VALUES ('Sponsor_' || (MOD((c-1)*5+s-1, 20)+1),
                    v_conf_acronym, SYSDATE, 10000 + s * 1000);
        END LOOP;

        -- 4 organizers per conference (400 total)
        FOR o IN 1..4 LOOP
            v_org_code := 'ORG_' || c || '_' || o;
            INSERT INTO Organizer (
                code, name, affiliation,
                address, phone, email
            ) VALUES (
                v_org_code,
                'Org ' || v_org_code,
                'Affil_' || MOD(o, 10),
                'Addr_' || o,
                '123-' || o,
                'org' || v_org_code || '@test.com'
            );
            INSERT INTO Membership (organizer_code, conference_acronym)
            VALUES (v_org_code, v_conf_acronym);
            v_area_acronym := CASE MOD(o, 3) WHEN 0 THEN 'DB_SYS'
                WHEN 1 THEN 'SW_ENG' ELSE 'AI' END;
            INSERT INTO AreaIndication (organizer_code,
                conference_acronym, area_acronym)
            VALUES (v_org_code, v_conf_acronym, v_area_acronym);
        END LOOP;

        -- 12 articles per conference (1200 total)
        FOR a IN 1..12 LOOP
            IF a <= 2 THEN v_category := 'Industrial Paper';
            ELSIF a <= 4 THEN v_category := 'Tutorial';
            ELSIF a <= 5 THEN v_category := 'Short Paper';
            ELSIF a <= 6 THEN v_category := 'Poster';
            ELSE v_category := 'Research Paper'; END IF;

            v_author_code := 'A_' || ((c - 1) * 12 + a);
            v_area_acronym := CASE MOD(a, 3)
                WHEN 0 THEN 'DB_SYS'
                WHEN 1 THEN 'SW_ENG' ELSE 'AI' END;

            INSERT INTO Article (conference_acronym, seq_number,
                title, category, status, contact_author_code)
            VALUES (v_conf_acronym, a,
                'Article ' || c || '_' || a,
                v_category, 'pending', v_author_code)
            RETURNING article_id INTO v_article_id;

            -- 3 authors per article
            INSERT INTO Authorship (article_id, author_code)
            VALUES (v_article_id, v_author_code);
            INSERT INTO Authorship (article_id, author_code)
            VALUES (v_article_id,
                'A_' || (MOD((c-1)*12+a, 3600)+1));
            INSERT INTO Authorship (article_id, author_code)
            VALUES (v_article_id,
                'A_' || (MOD((c-1)*12+a+1, 3600)+1));

            -- Article area indication (2 areas per article)
            INSERT INTO ArticleAreaIndication (article_id, area_acronym)
            VALUES (v_article_id, v_area_acronym);
            BEGIN
                INSERT INTO ArticleAreaIndication (article_id, area_acronym)
                VALUES (v_article_id, CASE v_area_acronym
                    WHEN 'DB_SYS' THEN 'SW_ENG'
                    WHEN 'SW_ENG' THEN 'AI'
                    ELSE 'DB_SYS' END);
            EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL;
            END;

            -- Contribution for Industrial Papers only
            IF v_category = 'Industrial Paper' THEN
                INSERT INTO Contribution (article_id, partner_code)
                VALUES (v_article_id, 'P_' || (MOD(a,480)+1));
                INSERT INTO Contribution (article_id, partner_code)
                VALUES (v_article_id, 'P_' || (MOD(a+1,480)+1));
            END IF;

            -- 3 reviews per article
            FOR r IN 1..3 LOOP
                v_review_code := 'REV_' || v_article_id || '_' || r;
                v_org_code := 'ORG_' || c || '_' || r;
                BEGIN
                    INSERT INTO AreaIndication (organizer_code,
                        conference_acronym, area_acronym)
                    VALUES (v_org_code, v_conf_acronym, v_area_acronym);
                EXCEPTION WHEN DUP_VAL_ON_INDEX THEN NULL;
                END;
                INSERT INTO Review (
                    code, review_date, content,
                    originality, significance,
                    quality, global_score,
                    article_id, reviewer_code
                ) VALUES (
                    v_review_code, SYSDATE,
                    'Review ' || v_article_id,
                    5+MOD(r,5),
                    5+MOD(r+1,5),
                    5+MOD(r+2,5),
                    ROUND((5+MOD(r,5)
                      +5+MOD(r+1,5)
                      +5+MOD(r+2,5))/3),
                    v_article_id, v_org_code
                );
            END LOOP;
        END LOOP;
    END LOOP;
    COMMIT;
END;
/
\end{sqlbox}

\clearpage

\section{Trigger Testing}

To check that all triggers work as expected, we wrote a testing script that tries both valid and invalid operations for each business rule. Each test is wrapped in a \texttt{BEGIN...EXCEPTION} block so it does not stop the script when an error is raised. The test checks \texttt{SQLCODE} to confirm it matches the expected error number.

\begin{infobox}
The full testing script is in \texttt{sql/05\_testing.sql}. It should be run after the tables, triggers, and population script. Individual trigger definitions are also available as standalone files inside \texttt{sql/triggers/}.
\end{infobox}

Here is an example of how we test BR1 (max 4 reviewers):

\begin{sqlbox}[title={Example: Testing BR1}]
-- Article 1 already has 3 reviews from the population script.
-- A 4th review should be accepted, a 5th should be blocked.
BEGIN
    INSERT INTO Review (code, review_date, article_id, reviewer_code)
    VALUES ('TEST_BR1_4', SYSDATE, 1, 'ORG_1_4');
    -- This succeeds (4th reviewer)

    INSERT INTO Review (code, review_date, article_id, reviewer_code)
    VALUES ('TEST_BR1_5', SYSDATE, 1, 'ORG_TEST');
    -- This should raise ORA-20001
    ROLLBACK;
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -20001 THEN
            DBMS_OUTPUT.PUT_LINE('BR1 PASS');
        END IF;
        ROLLBACK;
END;
/
\end{sqlbox}

The testing script covers all 13 business rules, including the compound triggers (BR9, BR13) and the CHECK constraints (BR4, BR10).

\clearpage

\section{Index Analysis}

Oracle automatically creates indexes for all PRIMARY KEY and UNIQUE columns. But it does not create indexes for FOREIGN KEY columns. Since many of our triggers and procedures filter on FK columns, we need to check the execution plans and add indexes where needed.

\subsection{Methodology}

For each critical query we follow these steps:
\begin{enumerate}[itemsep=4pt, topsep=6pt]
    \item Identify the query and which triggers/procedures use it.
    \item Run \texttt{EXPLAIN PLAN} to see how Oracle executes it without a custom index.
    \item If the plan shows a \texttt{TABLE ACCESS FULL} (full scan), create an index.
    \item Run \texttt{EXPLAIN PLAN} again to confirm the index is used.
\end{enumerate}

\begin{infobox}
The full analysis script is in \texttt{sql/06\_indexes.sql}. It uses \texttt{DBMS\_XPLAN.DISPLAY} to show the execution plans before and after creating the indexes.
\end{infobox}

\subsection{Query Q1: Review by article\_id}

This query appears in four triggers: BR1 (max reviewers), BR5/BR6 (status check), and BR13 (average score). It runs every time a review is inserted, updated, or deleted.

\begin{sqlbox}[title={Q1: COUNT reviews for a given article}]
SELECT COUNT(*) FROM Review
WHERE article_id = :NEW.article_id;
\end{sqlbox}

The column \texttt{Review.article\_id} is a foreign key but has no index. Oracle must scan all rows in Review to count how many belong to the article.

\begin{reasoningbox}
\texttt{Review.article\_id} is the most used FK column in the whole schema. It shows up in 4 triggers that fire on every DML on the Review table. With 3\,600 review rows, a full table scan is not the end of the world, but it is not needed either. This is the top-priority index.
\end{reasoningbox}

Plan BEFORE index:

\begin{lstlisting}[basicstyle=\ttfamily\small, language={}, numbers=none]
----------------------------------------------
| Operation              | Name              |
----------------------------------------------
| SELECT STATEMENT       |                   |
|  SORT AGGREGATE        |                   |
|   TABLE ACCESS FULL    | REVIEW            |
----------------------------------------------
\end{lstlisting}

Plan AFTER index:

\begin{lstlisting}[basicstyle=\ttfamily\small, language={}, numbers=none]
----------------------------------------------
| Operation              | Name              |
----------------------------------------------
| SELECT STATEMENT       |                   |
|  SORT AGGREGATE        |                   |
|   INDEX RANGE SCAN     | IDX_REVIEW_ART_ID |
----------------------------------------------
\end{lstlisting}

The full table scan is replaced by an \texttt{INDEX RANGE SCAN}, which reads only the index entries for the specific \texttt{article\_id} value.

\subsection{Query Q2: Review by reviewer\_code}

This query is used by OP2 (\texttt{prc\_get\_reviewer\_assignments}) to find which articles are assigned to a reviewer.

\begin{sqlbox}[title={Q2: Find reviews for a given reviewer}]
SELECT rev.article_id
FROM Review rev
WHERE rev.reviewer_code = 'ORG_1_1';
\end{sqlbox}

\begin{reasoningbox}
\texttt{Review.reviewer\_code} is a FK column with no index. Every time a reviewer opens the assignments page, Oracle scans the whole Review table. With an index, Oracle goes straight to the rows for that reviewer.
\end{reasoningbox}

Plan BEFORE index:

\begin{lstlisting}[basicstyle=\ttfamily\small, language={}, numbers=none]
----------------------------------------------
| Operation              | Name              |
----------------------------------------------
| SELECT STATEMENT       |                   |
|  TABLE ACCESS FULL     | REVIEW            |
----------------------------------------------
\end{lstlisting}

Plan AFTER index:

\begin{lstlisting}[basicstyle=\ttfamily\small, language={}, numbers=none]
-------------------------------------------------
| Operation                | Name               |
-------------------------------------------------
| SELECT STATEMENT         |                    |
|  TABLE ACCESS BY ROWID   | REVIEW             |
|   INDEX RANGE SCAN       | IDX_REVIEW_REV_CD  |
-------------------------------------------------
\end{lstlisting}

\subsection{Query Q3: Membership by conference\_acronym}

This query is used by the BR9 compound trigger to check that a conference still has at least 2 committee members after a deletion.

\begin{sqlbox}[title={Q3: Count members for a conference}]
SELECT COUNT(*) FROM Membership
WHERE conference_acronym = 'CONF_1';
\end{sqlbox}

\begin{reasoningbox}
Membership's PK is \texttt{(organizer\_code, conference\_acronym)}. Since \texttt{conference\_acronym} is the \emph{second} column in the composite PK, Oracle cannot use the PK index to search by \texttt{conference\_acronym} alone. This is how B-tree indexes work: they only support prefix-based lookups. We need a separate index with \texttt{conference\_acronym} as the first column.
\end{reasoningbox}

Plan BEFORE index:

\begin{lstlisting}[basicstyle=\ttfamily\small, language={}, numbers=none]
----------------------------------------------
| Operation              | Name              |
----------------------------------------------
| SELECT STATEMENT       |                   |
|  SORT AGGREGATE        |                   |
|   TABLE ACCESS FULL    | MEMBERSHIP        |
----------------------------------------------
\end{lstlisting}

Plan AFTER index:

\begin{lstlisting}[basicstyle=\ttfamily\small, language={}, numbers=none]
-----------------------------------------------
| Operation               | Name              |
-----------------------------------------------
| SELECT STATEMENT        |                   |
|  SORT AGGREGATE         |                   |
|   INDEX RANGE SCAN      | IDX_MEMB_CONF     |
-----------------------------------------------
\end{lstlisting}

\subsection{Index Definitions}

Based on the analysis above, we create three indexes:

\begin{sqlbox}[title={Index Definitions}]
-- most used FK, fires in 4 triggers
CREATE INDEX idx_review_article_id
    ON Review(article_id);

-- for the assignments page (OP2)
CREATE INDEX idx_review_reviewer_code
    ON Review(reviewer_code);

-- conference_acronym is 2nd in PK, need separate index (BR9)
CREATE INDEX idx_membership_conf
    ON Membership(conference_acronym);
\end{sqlbox}

\subsection{Summary}

Table~\ref{tab:indexes} shows all three indexes with the queries they speed up and the plan change.

\begin{table}[!ht]
\centering
\caption{Custom indexes created for ConferenceHub.}
\label{tab:indexes}
\small
\begin{tabularx}{\textwidth}{@{} l l l X @{}}
  \toprule
  Index & Table(Column) & Used by & Plan change \\
  \midrule
  \texttt{idx\_review\_article\_id}    & Review(article\_id)                & BR1, BR5/6, BR13 & FULL $\rightarrow$ RANGE SCAN \\
  \texttt{idx\_review\_reviewer\_code} & Review(reviewer\_code)             & OP2              & FULL $\rightarrow$ RANGE SCAN \\
  \texttt{idx\_membership\_conf}       & Membership(conference\_acronym)    & BR9              & FULL $\rightarrow$ RANGE SCAN \\
  \bottomrule
\end{tabularx}
\end{table}

\begin{reasoningbox}
We decided not to create indexes on columns that are already covered by existing PK or UNIQUE indexes. For example, \texttt{Authorship(article\_id)} is the first column of the PK \texttt{(article\_id, author\_code)}, so Oracle can already use the PK index for queries that filter by \texttt{article\_id}. Same thing for \texttt{AreaIndication} and \texttt{ArticleAreaIndication}.
\end{reasoningbox}

\begin{reasoningbox}
We also decided not to add too many indexes. Each extra index costs storage and slows down INSERT/UPDATE/DELETE because Oracle has to update both the table and the index. Our three indexes target the most important queries: the ones that fire on every Review operation (indexes 1 and 2) and the BR9 trigger (index 3).
\end{reasoningbox}
